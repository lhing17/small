---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2022/6/19 7:17
---

---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by G. Seinfeld.
--- DateTime: 2022/5/24 16:12
---

-----------------------------------------------------------------------------------
-- - - - - - - - - - - - - - - Global Help Functions - - - - - - - - - - - - - - --
-----------------------------------------------------------------------------------

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function getAdjacentPos(row, col)
    -- returns table containing all adjacent positions [1]:row [2]:col to given position
    -- INCLUDING SELF. to change this:
    -- add if (not (dx == 0 and dy == 0)) then ... end

    local result = {}
    for dx = -1, 1 do
        for dy = -1, 1 do
            result[#result + 1] = { row + dy, col + dx }
        end
    end
    return result
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function findNext(start, goal)
    -- Finds next step from start position to goal position in a matrix
    if start == goal then
        return goal
    end
    row, col = start[1], start[2]
    local adj = getAdjacentPos(start[1], start[2])
    dist = getDist(start, goal)

    for i = 1, #adj do
        local adjT = adj[i]
        if (getDist(adjT, goal) < dist) and
                i % 2 == 0        -- not picking diagonals (would cause too narrow corridors)
        then
            nextPos = adjT
            dist = getDist(nextPos, goal)
            --break           -- uncomment for more rectangular paths!
        end
    end
    return nextPos
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function getRandNeighbour(row, col, notDiag)
    if notDiag then
        local f = { -1, 1 }
        local d = f[math.random(1, 2)]
        if math.random() > 0.5 then
            return row + d, col
        else
            return row, col + d
        end
    else
        local dir = { math.random(-1, 1), math.random(-1, 1) }
        return row + dir[1], col + dir[2]
    end
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function withinBounds(r, c, height, width)
    return (r < height and r > 0 and c < width and c > 0)
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function prims(unvisited)
    len = #unvisited
    local root = table.remove(unvisited, 1)
    if #unvisited == 0 then
        return root, root
    end

    local visited = {}
    table.insert(visited, root)
    repeat
        local dist = 1e309    -- ~inf
        for i = 1, #visited do
            for j = 1, #unvisited do
                if (unvisited[j]:distanceTo(visited[i]) < dist) then
                    dist = unvisited[j]:distanceTo(visited[i])
                    v0 = visited[i]
                    endIndex = j
                end
            end
        end
        v1 = table.remove(unvisited, endIndex)
        v0:addNeighbour(v1)
        table.insert(visited, v1)
    until #visited == len

    return visited[1], visited[#visited]
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

-- source: https://stackoverflow.com/questions/2705793/how-to-get-number-of-entries-in-a-lua-table
function tableLength(T)
    local count = 0
    for _ in pairs(T) do
        count = count + 1
    end
    return count
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function table.clone(org)
    local newTable = {}
    for k, v in pairs(org) do
        newTable[k] = v
    end
    return newTable
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function getDist(start, goal)
    return math.sqrt(math.abs(goal[1] - start[1]) ^ 2 + math.abs(goal[2] - start[2]) ^ 2)
end

local random = math.random
local floor = math.floor
local ceil = math.ceil
local min = math.min
local max = math.max
local insert = table.insert

--seed = os.time()
--math.randomseed(seed)
-- print("seed: "..seed)  -- for debugging


---------------------------------------------------------------------------
-- - - - - - - - - - - - - - - - Tile object - - - - - - - - - - - - - - --
---------------------------------------------------------------------------

-- Tile objects:

--  * Keeps track of room association, if not in room (default): roomId = 0
--  * Has graphic symbol to represent what kind of tile this is in a level
--    *   " " for empty
--    *   "." for floor
--    *   "#" for wall
--    *   "<" for ascending staircase
--    *   ">" for descending staircase
--    *   "%" for soil
--    *   "*" for mineral vein
--    *   "'" for open door
--    *   "+" for closed door

Tile = { class, roomId }
Tile.__index = Tile

Tile.EMPTY = " "
Tile.FLOOR = "."
Tile.WALL = "#"
Tile.A_STAIRCASE = "<"
Tile.D_STAIRCASE = ">"
Tile.SOIL = "%"
Tile.VEIN = "*"
Tile.C_DOOR = "+"
Tile.O_DOOR = "'"

Tile.PLAYER = "@"
Tile.BOSS = "B"

function Tile:new(t)
    local tile = {}
    tile.class = t
    tile.roomId = 0

    setmetatable(tile, Tile)

    return tile

end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Tile:isWall()
    return (
            self.class == Tile.WALL or
                    self.class == Tile.SOIL or
                    self.class == Tile.VEIN
    )
end


---------------------------------------------------------------------------
-- - - - - - - - - - - - - - - - Room object - - - - - - - - - - - - - - --
---------------------------------------------------------------------------

-- Room is a Node-like object.

--  * Has unique id
--  * Keeps track of neighbouring rooms by keeping boolean value
--  * at index representing neighbours' id's

Room = { id, neighbours, center, hasStaircase }
Room.__index = Room

function Room:new(id)
    local room = {
        id = id,
        neighbours = {},
        center = {},
        hasStaircase = false
    }

    setmetatable(room, Room)

    return room
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Room:addNeighbour(other)
    table.insert(self.neighbours, other)
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Room:hasNeighbours()
    return tableLength(self.neighbours) > 1
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Room:setCenter(r, c)
    self.center = { r, c }
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Room:distanceTo(other)
    -- returns distance from self to other room's center.

    return math.sqrt(
            math.abs(self.center[1] - other.center[1]) ^ 2 +
                    math.abs(self.center[2] - other.center[2]) ^ 2
    )
end

---------------------------------------------------------------------------------------
-- - - - - - - - - - - - - - - - - - - Level object - - - - - - - - - - - - - - -- - --
---------------------------------------------------------------------------------------

-- A Level object consist of several Tile objects which together make up
-- one dungeon level.

Level = { height, width, matrix, rooms, entrances, staircases }
Level.__index = Level

Level.MIN_ROOM_SIZE = 3

Level.veinSpawnRate = 0.02
Level.soilSpawnRate = 0.05

function Level:new(height, width)
    if height < 10 or width < 10 then
        error("Level must have height>=10, width>=10")
    end

    local level = {
        height = height,
        width = width,
        matrix = {},
        rooms = {},
        entrances = {},
        staircases = {},
        rootRoom = nil,
        endRoom = nil
    }
    level.maxRoomSize = ceil(min(height, width) / 10) + 5
    level.maxRooms = ceil(max(height, width) / Level.MIN_ROOM_SIZE)
    -- Determines amount of random tiles built when generating corridors:
    level.scatteringFactor = ceil(max(height, width) / level.maxRoomSize)

    setmetatable(level, Level)
    return level
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:generateLevel()
    -- A default generation of a level including rooms, corridors to each room forming
    -- an MSF, staircases and doors. addCycles can be uncommented to dig more corridors.

    self:initMap()
    self:generateRooms()
    root = self:getRoomTree()
    self:buildCorridors(root)
    -- self:addCycles(5)
    self:addStaircases()
    self:addDoors()
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:initMap()

    -- Create void
    for i = -1, self.height + 1 do
        self.matrix[i] = {}
        for j = 0, self.width + 1 do
            self.matrix[i][j] = Tile:new(Tile.EMPTY)
        end
    end

    self:addWalls(0, 0, self.height + 1, self.width + 1)
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:printLevel ()

    for i = 0, self.height + 1 do
        local row = "  "
        for j = 0, self.width + 1 do
            row = row .. self.matrix[i][j].class .. Tile.EMPTY
            --row=row..self.matrix[i][j].roomId..Tile.EMPTY    -- for exposing room-ids
        end
        print(row)
    end
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:getRandRoom()
    -- return: Random room in level
    local i = random(1, #self.rooms)
    return self.rooms[i]
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:getRoot()
    -- return: Room that is root of room tree if such has been generated.
    return self.rootRoom
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:getEnd()
    -- return: Leaf room added last to tree if such has been generated.
    return self.endRoom
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:getStaircases()
    -- Index [1] for row, [2] for col on individual entry for individual staircase.
    return self.staircases
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:getTile(r, c)
    return self.matrix[r][c]
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:isRoom(row, col)
    return (self:getTile(row, col).roomId ~= 0)
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:setMaxRooms(m)
    self.maxRooms = m
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:setScatteringFactor(f)
    self.scatteringFactor = f
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:setMaxRoomSize(m)
    if m > min(self.height, self.width) or m < 3 then
        error("MaxRoomSize can't be bigger than height-3/width-3 or smaller than 3")
    end
    self.maxRoomSize = m
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:generateRooms()
    print(self.maxRooms)
    for i = 1, self.maxRooms do
        self:generateRoom()
    end

end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:generateRoom()
    -- Will randomly place rooms across tiles (no overlapping).



    local startRow = random(1, self.height - self.maxRoomSize)
    local startCol = random(1, self.width - self.maxRoomSize)

    local height = random(Level.MIN_ROOM_SIZE, self.maxRoomSize)
    local width = random(Level.MIN_ROOM_SIZE, self.maxRoomSize)
    print(startRow, startCol, height, width)

    for i = startRow - 1, startRow + height + 1 do
        for j = startCol - 1, startCol + width + 1 do

            if (self:isRoom(i, j)) then
                return            -- Room is overlapping other room->room is discarded
            end
        end
    end
    self:buildRoom(startRow, startCol, startRow + height, startCol + width)
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:getRoomTree()
    if #self.rooms < 1 then
        error("Can't generate room tree, no rooms exists")
    end

    local root, lastLeaf = prims(table.clone(self.rooms))
    self.rootRoom = root
    self.endRoom = lastLeaf

    return root
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:buildRoom(startR, startC, endR, endC)
    -- init room object and paint room onto tiles.

    local id = #self.rooms + 1
    local room = Room:new(id)
    local r, c = endR - floor((endR - startR) / 2), endC - floor((endC - startC) / 2)
    room:setCenter(r, c)
    insert(self.rooms, room)

    for i = startR, endR do
        for j = startC, endC do
            local tile = self:getTile(i, j)
            tile.roomId, tile.class = id, Tile.FLOOR
        end
    end
    self:addWalls(startR - 1, startC - 1, endR + 1, endC + 1)
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:buildCorridors(root)
    -- Recursive DFS function for building corridors to every neighbour of a room (root)

    for i = 1, #root.neighbours do
        local neigh = root.neighbours[i]
        self:buildCorridor(root, neigh)
        self:buildCorridors(neigh)
    end
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:buildCorridor(from, to)
    -- Parameters from and to are both Room-objects.

    local start, goal = from.center, to.center
    local nextTile = findNext(start, goal)
    repeat
        local row, col = nextTile[1], nextTile[2]
        self:buildTile(row, col)

        if random() < self.scatteringFactor * 0.05 then
            self:buildRandomTiles(row, col)    -- Makes the corridors a little more interesting
        end
        nextTile = findNext(nextTile, goal)
    until (self:getTile(nextTile[1], nextTile[2]).roomId == to.id)

    insert(self.entrances, { row, col })
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:buildTile(r, c)
    -- Builds floor tile surrounded by walls.
    -- Only floor and empty tiles around floor tiles turns to walls.

    local adj = getAdjacentPos(r, c)
    self:getTile(r, c).class = Tile.FLOOR
    for i = 1, #adj do
        r, c = adj[i][1], adj[i][2]
        if not (self:getTile(r, c).class == Tile.FLOOR) then
            self:placeWall(r, c)
        end
    end
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:addDoors(maxDoors)
    -- Adds open or closed door randomly to entrance tiles.
    if #self.entrances == 0 or #self.rooms < 2 then
        return
    end
    if not maxDoors then
        maxDoors = #self.entrances
    end

    for i = 1, maxDoors do
        e = self.entrances[i]
        if self:isValidEntrance(e[1], e[2]) then
            tile = self:getTile(e[1], e[2])
            if random() > 0.5 then
                tile.class = Tile.C_DOOR
            else
                tile.class = Tile.O_DOOR
            end
        end
    end
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:addStaircases(maxStaircases)
    -- Adds both descending and ascending staircases to random rooms.
    -- Number of staircases depend on number of rooms.

    if (not maxStaircases) or (maxStaircases > #self.rooms) then
        maxStaircases = ceil(#self.rooms - (#self.rooms / 2)) + 1
    end
    local staircases = random(2, maxStaircases)

    repeat
        local room = self:getRandRoom()
        if not room.hasStaircase or #self.rooms == 1 then
            self:placeStaircase(room, staircases)
            staircases = staircases - 1
        end
    until staircases == 0
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:addWalls(startR, startC, endR, endC)
    -- Places walls on circumference of given rectangle.

    -- Upper and lower sides
    for j = startC, endC do
        self:placeWall(startR, j)
        self:placeWall(endR, j)
    end

    -- Left and right sides
    for i = startR, endR do
        self:placeWall(i, startC)
        self:placeWall(i, endC)
    end
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:placeWall(r, c)
    -- Places wall at given coordinate. Could either place
    -- regular wall, soil or mineral vein

    local tile = self:getTile(r, c)

    if random() <= Level.veinSpawnRate then
        tile.class = Tile.VEIN
    elseif random() <= Level.soilSpawnRate then
        tile.class = Tile.SOIL
        Level.soilSpawnRate = 0.6     -- for clustering
    else
        tile.class = Tile.WALL
        Level.soilSpawnRate = 0.05
    end
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:placeStaircase(room, staircases)
    -- Places staircase in given room.
    -- Position is random number of steps away from center.

    local steps = random(0, floor(self.maxRoomSize / 2))

    local nRow, nCol = room.center[1], room.center[2]
    repeat
        row, col = nRow, nCol
        repeat
            nRow, nCol = getRandNeighbour(row, col)
        until self:getTile(nRow, nCol).class == Tile.FLOOR
        steps = steps - 1
    until (self:getTile(nRow, nCol).roomId ~= room.id or steps <= 0)

    if staircases % 2 == 0 then
        self:getTile(row, col).class = Tile.D_STAIRCASE
    else
        self:getTile(row, col).class = Tile.A_STAIRCASE
    end
    room.hasStaircase = true
    insert(self.staircases, { row, col })
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:isValidEntrance(row, col)
    -- Tile is a valid entrance position if there is a wall above and below it or
    -- to the left and to the right of it.
    return (
            (self:getTile(row + 1, col):isWall() and self:getTile(row - 1, col):isWall()) or
                    (self:getTile(row, col + 1):isWall() and self:getTile(row, col - 1):isWall())
    )
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:getAdjacentTiles(row, col)
    -- returns table containing all adjacent tiles to given position.
    -- Including self!

    local result = {}
    local adj = getAdjacentPos(row, col)
    for i = 1, #adj do
        local _row, _col = adj[i][1], adj[i][2]
        insert(result, self:getTile(_row, _col))
    end
    return result
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:buildRandomTiles(r, c)
    -- Creates random floor tiles starting from given tile.

    local rand = random(1, self.scatteringFactor)
    for _ = 1, rand do
        local nr, nc = getRandNeighbour(r, c, true)

        if (self:getTile(nr, nc).roomId == 0 and
                withinBounds(nr, nc, self.height, self.width)) then
            self:buildTile(nr, nc)
            r, c = nr, nc
        end
    end
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function Level:addCycles(maxCycles)
    -- Adds corridors between random rooms.

    for _ = 1, maxCycles do
        from = self:getRandRoom()
        to = self:getRandRoom()
        self:buildCorridor(from, to)
    end
end

---------------------------------------------------------------------------
-- - - - - - - - - - - - - - - Dungeon object - - - - - - - - - - - - - - -
---------------------------------------------------------------------------

-- Dungeon objects have several levels (consisting of Level objects) which
-- together represent a whole dungeon.

Dungeon = { nrOfLevels, height, width, levels }
Dungeon.__index = Dungeon

function Dungeon:new(nrOfLevels, height, width)
    local dungeon = {}
    dungeon.nrOfLevels = nrOfLevels
    dungeon.height = height
    dungeon.width = width
    dungeon.levels = {}

    setmetatable(dungeon, Dungeon)
    return dungeon
end

function Dungeon:generateDungeon(advanced, maxRooms, maxRoomSize, scatteringFactor)
    for i = 1, self.nrOfLevels do
        newLevel = Level:new(self.height, self.width)
        if advanced then
            newLevel:setMaxRooms(maxRooms)
            newLevel:setMaxRoomSize(maxRoomSize)
            newLevel:setScatteringFactor(scatteringFactor)
        end
        newLevel:generateLevel()
        self.levels[i] = newLevel
    end
end

function Dungeon:printDungeon()
    for i = 1, #self.levels do
        local s = "L E V E L  " .. i
        local space = ""
        for _ = 1, math.floor((self.width + 2) / 2 - (string.len(s)) / 4) do
            space = space .. "  "
        end
        print(space .. s .. space)
        self.levels[i]:printLevel()
        print()
    end
end

-----------------------------------------------------------------------------------
-- - - - - - - - - - - Help functions for main examples - - - - - - - - - - - - - -
-----------------------------------------------------------------------------------

function initPlayer(level)
    c = level:getRoot().center
    adj = getAdjacentPos(c[1], c[2])
    i = 1
    repeat
        endR, endC = adj[i][1], adj[i][2]
        i = i + 1
    until level:getTile(endR, endC).class == Tile.FLOOR

    level:getTile(endR, endC).class = Tile.PLAYER
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

function initBoss(level)
    c = level:getEnd().center
    adj = getAdjacentPos(c[1], c[2])
    i = 1
    repeat
        endR, endC = adj[i][1], adj[i][2]
        i = i + 1
    until level:getTile(endR, endC).class == Tile.FLOOR

    level:getTile(endR, endC).class = Tile.BOSS
end

-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

-----------------------------------------------------------------------------------
-- - - - - - - - - - - - - - - - Examples of main - - - - - - - - - - - - - - - - -
-----------------------------------------------------------------------------------

-- Example of generating a dungeon with:
--  * default settings by using generateDungeon.
--  * "Advanced" settings with max nr of rooms, room size and scattering factor.
--require 'util.common'

function generate_map()

    -- Settings for level sizes and number of levels in dungeon.
    height = 20
    width = 30
    nrOfLevels = 1

    dungeon = Dungeon:new(nrOfLevels, height, width)

    -- generate with default settings
    --dungeon:generateDungeon()

    -- generate with advanced settings,
    -- params: (advanced, maxRooms, maxRoomSize, scatteringFactor)
    dungeon:generateDungeon(true, 20, 8, 10)

    -- inits a player in level 1, a boss in last level
    initPlayer(dungeon.levels[1])
    initBoss(dungeon.levels[#dungeon.levels])

    dungeon:printDungeon()
    return dungeon
    --base.printTable(dungeon.levels[1])
end





-- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### -- ##### --

-- Example of generating one level with customized settings.

-- Some targeted functions to play with:
--  * setMaxRooms: maximum nr of rooms.
--  * setMaxRoomSize: keep it lower than height/width-3 though!
--  * setScatteringFactor: increases random scattering of tiles when forming corridors.
--  * addCycles: adds random cycles between rooms up to parameter value.

function generate_map_custom()
    height = 40
    width = 60
    level = Level:new(height, width)
    level:setMaxRooms(5)
    level:setMaxRoomSize(5)
    level:setScatteringFactor(10)
    Level.veinSpawnRate = 0.4
    level:initMap(level.height, level.width)
    level:generateRooms()
    root = level:getRoomTree()
    level:buildCorridors(root)
    level:buildCorridor(root, level:getEnd())
    level:addCycles(10)
    level:addStaircases(10)
    level:addDoors()
    initBoss(level)
    initPlayer(level)
    level:printLevel()
end

--mainCustomizedLevel()
--generate_map()